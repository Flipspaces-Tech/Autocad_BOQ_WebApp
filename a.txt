// VisJsonNet.cs  (C# 7.3 compatible, AutoCAD 2022, x64)
// References: acmgd.dll, acdbmgd.dll, accoremgd.dll  (Copy Local = False)
//
// ✅ Generates TWO JSON files:
// 1) vis_export_visibility.json  -> ONLY blocks that have Visibility (dynamic blocks with visibility prop)
//    Grouped by: (baseName + visibility), also includes chairCount
// 2) vis_export_all.json         -> ALL modelspace block references (including non-dynamic)
//    Grouped by: (baseName), includes totalCount
//
// ✅ Fixes *U### names by using DynamicBlockTableRecord for baseName.
// ✅ Counts chairs from evaluated anonymous block record (br.BlockTableRecord) as fallback.
//
// Commands:
//   NETLOAD this DLL
//   VISJSONNET
//
// Output folder:
//   C:\Users\admin\Documents\AUTOCAD_WEBAPP\EXPORTS\

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.Runtime;

namespace DwgExtractPlugin
{
    public class VisJsonNet : IExtensionApplication
    {
        public void Initialize() { }
        public void Terminate() { }

        [CommandMethod("PINGNET")]
        public void PingNet()
        {
            var doc = Autodesk.AutoCAD.ApplicationServices.Core.Application.DocumentManager.MdiActiveDocument;
            if (doc != null) doc.Editor.WriteMessage("\n✅ PINGNET OK\n");
        }

        // Run this after NETLOAD:
        // Command: VISJSONNET
        [CommandMethod("VISJSONNET")]
        public void VisJsonNetCommand()
        {
            Document doc = Autodesk.AutoCAD.ApplicationServices.Core.Application.DocumentManager.MdiActiveDocument;
            if (doc == null)
                throw new System.Exception("No active document.");

            Database db = doc.Database;

            string dwgFullPath = db.Filename;
            if (string.IsNullOrWhiteSpace(dwgFullPath))
                dwgFullPath = doc.Name;

            string dwgFileName = Path.GetFileName(dwgFullPath);

            string outDir = @"C:\Users\admin\Documents\AUTOCAD_WEBAPP\EXPORTS";
            Directory.CreateDirectory(outDir);

            string outJsonVisibility = Path.Combine(outDir, "vis_export_visibility.json");
            string outJsonAll = Path.Combine(outDir, "vis_export_all.json");

            // (1) visibility groups: baseName + visibility
            var visGrouped = new Dictionary<string, VisAgg>(StringComparer.OrdinalIgnoreCase);

            // (2) all groups: baseName only
            var allGrouped = new Dictionary<string, AllAgg>(StringComparer.OrdinalIgnoreCase);

            int totalInserts = 0;
            int dynamicProcessed = 0;
            int visKept = 0;

            using (Transaction tr = db.TransactionManager.StartTransaction())
            {
                ObjectId msId = SymbolUtilityServices.GetBlockModelSpaceId(db);
                BlockTableRecord ms = (BlockTableRecord)tr.GetObject(msId, OpenMode.ForRead);

                foreach (ObjectId id in ms)
                {
                    if (!id.ObjectClass.IsDerivedFrom(RXObject.GetClass(typeof(BlockReference))))
                        continue;

                    totalInserts++;

                    var br = (BlockReference)tr.GetObject(id, OpenMode.ForRead);

                    // Base name (fixes *U### for dynamics)
                    string baseName = Safe(GetBaseName(tr, br));
                    if (string.IsNullOrWhiteSpace(baseName))
                        baseName = Safe(br.Name);

                    // ---------- (2) ALL JSON aggregation ----------
                    {
                        AllAgg a;
                        if (!allGrouped.TryGetValue(baseName, out a))
                        {
                            a = new AllAgg
                            {
                                BlockName = baseName,
                                TotalCount = 0,
                                DynamicCount = 0
                            };
                            allGrouped[baseName] = a;
                        }
                        a.TotalCount += 1;
                        if (br.IsDynamicBlock) a.DynamicCount += 1;
                    }

                    // ---------- (1) VISIBILITY JSON aggregation ----------
                    string vis = "";
                    if (br.IsDynamicBlock)
                    {
                        dynamicProcessed++;
                        vis = GetVisibilityState(br);
                    }

                    if (!string.IsNullOrWhiteSpace(vis))
                    {
                        visKept++;

                        // chair count: 1) dyn property, 2) evaluated anonymous BTR scan
                        int chairCount = GetChairCountFromDynProps(br);
                        if (chairCount <= 0)
                            chairCount = CountNestedChairsFromEvaluatedBTR(tr, db, br);

                        string key = baseName + "||" + vis;

                        VisAgg v;
                        if (!visGrouped.TryGetValue(key, out v))
                        {
                            v = new VisAgg
                            {
                                TableName = baseName,
                                Visibility = vis,
                                TableCount = 0,
                                ChairCount = 0
                            };
                            visGrouped[key] = v;
                        }

                        v.TableCount += 1;
                        v.ChairCount += chairCount;
                    }
                }

                tr.Commit();
            }

            // Write VISIBILITY JSON
            string jsonVis = BuildVisibilityJson(dwgFileName, totalInserts, dynamicProcessed, visKept, visGrouped.Values.ToList());
            File.WriteAllText(outJsonVisibility, jsonVis, Encoding.UTF8);

            // Write ALL JSON
            string jsonAll = BuildAllJson(dwgFileName, totalInserts, allGrouped.Values.ToList());
            File.WriteAllText(outJsonAll, jsonAll, Encoding.UTF8);

            var d = Autodesk.AutoCAD.ApplicationServices.Core.Application.DocumentManager.MdiActiveDocument;
            if (d != null)
            {
                d.Editor.WriteMessage("\n✅ VISJSONNET wrote:\n");
                d.Editor.WriteMessage("  - " + outJsonVisibility + "\n");
                d.Editor.WriteMessage("  - " + outJsonAll + "\n");
            }
        }

        // ---------------- models ----------------

        private class VisAgg
        {
            public string TableName;
            public string Visibility;
            public int TableCount;
            public int ChairCount;
        }

        private class AllAgg
        {
            public string BlockName;
            public int TotalCount;
            public int DynamicCount;
        }

        // ---------------- JSON builders ----------------

        private static string BuildVisibilityJson(string dwg, int total, int dynProcessed, int kept, List<VisAgg> items)
        {
            items = items
                .OrderBy(x => x.TableName, StringComparer.OrdinalIgnoreCase)
                .ThenBy(x => x.Visibility, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var sb = new StringBuilder();
            sb.Append("{\n");
            sb.Append("  \"dwg\": ").Append(JsonStr(dwg)).Append(",\n");
            sb.Append("  \"totalInserts\": ").Append(total.ToString(CultureInfo.InvariantCulture)).Append(",\n");
            sb.Append("  \"dynamicProcessed\": ").Append(dynProcessed.ToString(CultureInfo.InvariantCulture)).Append(",\n");
            sb.Append("  \"visibilityKept\": ").Append(kept.ToString(CultureInfo.InvariantCulture)).Append(",\n");
            sb.Append("  \"items\": [\n");

            for (int i = 0; i < items.Count; i++)
            {
                var it = items[i];
                sb.Append("    {\n");
                sb.Append("      \"tableName\": ").Append(JsonStr(it.TableName)).Append(",\n");
                sb.Append("      \"visibility\": ").Append(JsonStr(it.Visibility)).Append(",\n");
                sb.Append("      \"tableCount\": ").Append(it.TableCount.ToString(CultureInfo.InvariantCulture)).Append(",\n");
                sb.Append("      \"chairCount\": ").Append(it.ChairCount.ToString(CultureInfo.InvariantCulture)).Append("\n");
                sb.Append("    }");
                if (i < items.Count - 1) sb.Append(",");
                sb.Append("\n");
            }

            sb.Append("  ]\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        private static string BuildAllJson(string dwg, int total, List<AllAgg> items)
        {
            items = items
                .OrderBy(x => x.BlockName, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var sb = new StringBuilder();
            sb.Append("{\n");
            sb.Append("  \"dwg\": ").Append(JsonStr(dwg)).Append(",\n");
            sb.Append("  \"totalInserts\": ").Append(total.ToString(CultureInfo.InvariantCulture)).Append(",\n");
            sb.Append("  \"items\": [\n");

            for (int i = 0; i < items.Count; i++)
            {
                var it = items[i];
                sb.Append("    {\n");
                sb.Append("      \"blockName\": ").Append(JsonStr(it.BlockName)).Append(",\n");
                sb.Append("      \"totalCount\": ").Append(it.TotalCount.ToString(CultureInfo.InvariantCulture)).Append(",\n");
                sb.Append("      \"dynamicCount\": ").Append(it.DynamicCount.ToString(CultureInfo.InvariantCulture)).Append("\n");
                sb.Append("    }");
                if (i < items.Count - 1) sb.Append(",");
                sb.Append("\n");
            }

            sb.Append("  ]\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        // ---------------- helpers ----------------

        private static string JsonStr(string s)
        {
            if (s == null) s = "";
            s = s.Replace("\\", "\\\\").Replace("\"", "\\\"");
            s = s.Replace("\r", "\\r").Replace("\n", "\\n").Replace("\t", "\\t");
            return "\"" + s + "\"";
        }

        private static string Safe(string s) { return s ?? ""; }

        /// <summary>
        /// Base name for dynamic blocks:
        /// - br.DynamicBlockTableRecord => named base definition (e.g. "ROUND MEETING TABLE")
        /// Evaluated name:
        /// - br.BlockTableRecord => anonymous (*U###)
        /// </summary>
        private static string GetBaseName(Transaction tr, BlockReference br)
        {
            try
            {
                if (br.IsDynamicBlock)
                {
                    ObjectId baseBtrId = br.DynamicBlockTableRecord;
                    if (!baseBtrId.IsNull)
                    {
                        var btr = (BlockTableRecord)tr.GetObject(baseBtrId, OpenMode.ForRead);
                        if (btr != null && !string.IsNullOrEmpty(btr.Name))
                            return btr.Name;
                    }
                }
            }
            catch { }
            return br.Name;
        }

        private static string GetVisibilityState(BlockReference br)
        {
            try
            {
                if (!br.IsDynamicBlock) return "";

                var props = br.DynamicBlockReferencePropertyCollection;
                foreach (DynamicBlockReferenceProperty p in props)
                {
                    if (p == null) continue;
                    var n = (p.PropertyName ?? "").ToUpperInvariant();
                    if (n.Contains("VISIBILITY"))
                    {
                        return (p.Value != null) ? p.Value.ToString() : "";
                    }
                }
            }
            catch { }
            return "";
        }

        private static int GetChairCountFromDynProps(BlockReference br)
        {
            try
            {
                if (!br.IsDynamicBlock) return 0;

                var props = br.DynamicBlockReferencePropertyCollection;
                foreach (DynamicBlockReferenceProperty p in props)
                {
                    if (p == null) continue;

                    string n = (p.PropertyName ?? "").ToUpperInvariant();
                    if (!(n.Contains("CHAIR") || n.Contains("SEAT") || n.Contains("QTY") || n.Contains("COUNT")))
                        continue;

                    string val = (p.Value != null) ? p.Value.ToString() : "";

                    int parsed;
                    if (int.TryParse(val, NumberStyles.Any, CultureInfo.InvariantCulture, out parsed))
                        return parsed;

                    double d;
                    if (double.TryParse(val, NumberStyles.Any, CultureInfo.InvariantCulture, out d))
                        return (int)Math.Round(d);
                }
            }
            catch { }
            return 0;
        }

        private static bool LooksLikeChair(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return false;
            return name.IndexOf("CHAIR", StringComparison.OrdinalIgnoreCase) >= 0
                || name.IndexOf("SEAT", StringComparison.OrdinalIgnoreCase) >= 0
                || name.IndexOf("CHR", StringComparison.OrdinalIgnoreCase) >= 0;
        }

        /// <summary>
        /// ✅ Robust fallback:
        /// Scan the evaluated anonymous BTR referenced by br.BlockTableRecord (typically *U### for this instance),
        /// and count nested BlockReferences that look like chairs.
        /// </summary>
        private static int CountNestedChairsFromEvaluatedBTR(Transaction tr, Database db, BlockReference br)
        {
            try
            {
                ObjectId evalBtrId = br.BlockTableRecord;
                if (evalBtrId.IsNull) return 0;

                var evalBtr = (BlockTableRecord)tr.GetObject(evalBtrId, OpenMode.ForRead);
                if (evalBtr == null) return 0;

                int chairCount = 0;

                foreach (ObjectId cid in evalBtr)
                {
                    if (!cid.ObjectClass.IsDerivedFrom(RXObject.GetClass(typeof(BlockReference))))
                        continue;

                    var child = (BlockReference)tr.GetObject(cid, OpenMode.ForRead);

                    string childBase = Safe(GetBaseName(tr, child));
                    string childRaw = Safe(child.Name);

                    if (LooksLikeChair(childBase) || LooksLikeChair(childRaw))
                        chairCount++;
                }

                return chairCount;
            }
            catch
            {
                return 0;
            }
        }
    }
}
